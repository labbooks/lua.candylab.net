---
layout: post
title: NGINX配置初始化过程
description: NGINX配置初始化过程
date:   2016-09-17 22:50:18 +0800 
tags: [lua]
categories: [topic]
---
nginx解析配置文件，将解析出来得配置存放在ngx_cycle_s的conf_ctx中，conf_ctx是个四级指针，因为保存这些配置需要context，而这些context是有层级关系，最终的配置结构如图：


图片：27767798_1370416906jegE.png
<img src="http://orchina-blog.stor.sinaapp.com/1446608142.png" alt="27767798_1370416906jegE.png" /> 

 http模块的配置有些复杂，由于server的配置还可以出现在http模块中，同时location的配置可以出现在http模块或者server模块中，所以对于http来说也就是最上面的那个ngx_http_ctx_conf_t有srv_conf和loc_conf是十分有必要的，这两个指针后面的结构体数组保存了在http中的那些server的和location的配置。同样对于每个server来说，不需要单独的main配置了，直接引用main的就可以。每个server必须有自己单独的ngx_http_core_srv_conf_t，来保存当前server块内的配置，这个配置最后会和http的里面的ngx_http_core_srv_conf_t做merge，这个merge是把父server的配置merge到子server配置上面。对于location的配置，在http和server中都可以配置，那么merge的操作需要首先把http的location配置merge到每个server配置中，然后每个server的location配置再和每个location模块中的配置进行merge，这里location配置需要merge两次。举例ngx_http_core_module模块merge的过程：



图片：27767798_1370417515HdmN.png
<img src="http://orchina-blog.stor.sinaapp.com/1446608052.png" alt="27767798_1370417515HdmN.png" />

 merge过程是按照module一个一个module的merge，第一步从main配置里面的servers，遍历每个server，把main里面的server配置merge到每个server的配置中，然后把main里面的location配置merge到每个server的location的配置中。第二步再次遍历每个server的locations，把这个server的location的配置merge到具体的每个location中。
代码：

```c
static char *
ngx_http_merge_servers(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf,
    ngx_http_module_t *module, ngx_uint_t ctx_index) //cmcf代表http的main配置
{ 
    char *rv; 
    ngx_uint_t s; 
    ngx_http_conf_ctx_t *ctx, saved;
    ngx_http_core_loc_conf_t *clcf;
    ngx_http_core_srv_conf_t **cscfp;

    cscfp = cmcf->servers.elts;             //得到servers数组，cmcf是main层的配置
    ctx = (ngx_http_conf_ctx_t *) cf->ctx; //ctx是main的 ngx_http_conf_ctx_t
    saved = *ctx;
    rv = NGX_CONF_OK;

    for (s = 0; s < cmcf->servers.nelts; s++) { //遍历每个server，把main的配置merge到每个server中

        /* merge the server{}s' srv_conf's */

        ctx->srv_conf = cscfp[s]->ctx->srv_conf; 

        if (module->merge_srv_conf) {           //调用模块的merge server操作
            rv = module->merge_srv_conf(cf, saved.srv_conf[ctx_index],
                                        cscfp[s]->ctx->srv_conf[ctx_index]); //save.srv_conf是父server配置，cscf->ctx->srv_conf是当前server的配置，相当于图中的第一步
            if (rv != NGX_CONF_OK) {
                goto failed;
            } 
        } 

        if (module->merge_loc_conf) { //调用模块的merge location操作，把父location配置merge到每个server的location配置相当于图中的第一步

            /* merge the server{}'s loc_conf */

            ctx->loc_conf = cscfp[s]->ctx->loc_conf;

            rv = module->merge_loc_conf(cf, saved.loc_conf[ctx_index],
                                        cscfp[s]->ctx->loc_conf[ctx_index]);
            if (rv != NGX_CONF_OK) {
                goto failed;
            } 

            /* merge the locations{}' loc_conf's */
            clcf = cscfp[s]->ctx->loc_conf[ngx_http_core_module.ctx_index];

            rv = ngx_http_merge_locations(cf, clcf->locations,
                                          cscfp[s]->ctx->loc_conf,
                                          module, ctx_index); //该merge每个server的location配置到每个location的配置中了，相当于图中的第二步
            if (rv != NGX_CONF_OK) {
                goto failed;
            }
        }
    }
```

server中location和location的merge过程

```c
static char *
ngx_http_merge_locations(ngx_conf_t *cf, ngx_queue_t *locations,
    void **loc_conf, ngx_http_module_t *module, ngx_uint_t ctx_index)
{
    char *rv;
    ngx_queue_t *q;
    ngx_http_conf_ctx_t *ctx, saved;
    ngx_http_core_loc_conf_t *clcf;
    ngx_http_location_queue_t *lq;

    if (locations == NULL) {
        return NGX_CONF_OK;
    }

    ctx = (ngx_http_conf_ctx_t *) cf->ctx;
    saved = *ctx;

    for (q = ngx_queue_head(locations);      //遍历server中的locations队列
         q != ngx_queue_sentinel(locations);
         q = ngx_queue_next(q))
    {
        lq = (ngx_http_location_queue_t *) q;

        clcf = lq->exact ? lq->exact : lq->inclusive; 
        ctx->loc_conf = clcf->loc_conf;

        rv = module->merge_loc_conf(cf, loc_conf[ctx_index],
                                    clcf->loc_conf[ctx_index]); //loc_conf代表server下location配置，clcf->loc_conf代表每个location的配置
        if (rv != NGX_CONF_OK) {
            return rv;
        }

        rv = ngx_http_merge_locations(cf, clcf->locations, clcf->loc_conf,
                                      module, ctx_index);        //递归嵌套location
        if (rv != NGX_CONF_OK) {
            return rv;
        }
    }
```


感谢作者分享，原文地址：
http://blog.chinaunix.net/uid-27767798-id-3757684.html