---
layout: post
title: OPENRESTY 中的简易HTTP加密
description: OPENRESTY 中的简易HTTP加密
date:   2016-09-17 22:50:18 +0800 
tags: [lua]
categories: [topic]
---
需求
速度快；
可逆；
容易实现，不存在语言障碍；
思考
将一个任意内容的字符串作为密钥，从明文中取等长字符串，逐字节将明文和密钥进行异或计算，得到密文。循环处理整个明文，得到完整密文。对密文进行同样的运算即可解密。

算法
```lua
local bit = require("bit")
 
--- 使用密钥对字符串进行加密(解密)
--
-- @param string str 原始字符串(加密后的密文)
-- @param string key 密钥
-- @return string 加密后的密文(原始字符串)
local function encrypt(str, key)
    local strBytes = { str:byte(1, #str) }
    local keyBytes = { key:byte(1, #key) }
    local n, keyLen = 1, #keyBytes
 
    for i = 1, #strBytes do
        strBytes[i] = bit.bxor(strBytes[i], keyBytes[n])
 
        n = n + 1
 
        if n > keyLen then
            n = n - keyLen
        end
    end
 
    return string.char(unpack(strBytes))
end
```
测试

```lua
-- 加密密钥
local ENCRYPT_KEY = "EFH@^&%#^&*@#G@&()*!&*@)(#$!@$GJHGHJ$G#HJ!$G"
 
-- 原始字符串
local originalStr = "Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world!"
 
-- 加密字符串
local encryptStr = encrypt(originalStr, ENCRYPT_KEY)
 
-- 打印密文
print("encryptStr:" .. encryptStr)
 
-- 打印原文
print("originalStr:" .. encrypt(encryptStr, ENCRYPT_KEY))

```


处理加密 POST 数据
客户端将通讯数据组成 URI 模式字符串，并用本地语言实现加密算法，将加密后的密文通过 POST 方式提交，服务端使用加密算法将 POST 数据还原成明文并解析成参数表。


```lua
-- 准备body数据
ngx.req.read_body()
 
-- 解密body数据，并解析成table格式
local postData = {}
local encryptData = ngx.req.get_body_data()
 
if encryptData then
    postData = ngx.decode_args(encrypt(encryptData, ENCRYPT_KEY))
end
```

感谢原作者分享：
http://zivn.me/?p=183