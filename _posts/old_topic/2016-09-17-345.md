---
layout: post
title: Openresty定时器ngx.timer通过Redis的pubsub进行通信
description: Openresty定时器ngx.timer通过Redis的pubsub进行通信
date:   2016-09-17 22:50:18 +0800 
categories: [topic]
---
做一个小实验：

先打开一个redis-cli, 监听所有事件：

```
127.0.0.1:6379>  config set notify-keyspace-events KEA 
127.0.0.1:6379> psubscribe __key*@0__:* 
```

再开一个redis-cli,进行publish与subscribe操作：

```
127.0.0.1:6379> publish chatroom "123"
127.0.0.1:6379> publish chatroom "abc"
```

然于，打开一个python redis client进行subscribe:
```
r = redis.StrictRedis(host='localhost', port=6379, db=0, password='candylab.net')

ps = rc.pubsub()

ps.subscribe('chatroom')

for item in ps.listen():  
    if item['type'] == 'message':  
        print item['data']  
```


[Python Redis客户端](https://github.com/andymccurdy/redis-py)

[LUA Redis客户端](https://github.com/nrk/redis-lua)

[LUA Redis客户端](https://github.com/hoisie/redis)



实际上我们是可以，在OpenResty的定时器处理过程中对Redis进行操作的， 这种对redis的数据操作的API是不会在OpenResty的各个阶段被disabled，所以我们可以通过redis进行表数据共享，通过订阅与支持Redis客户端口的相应语言进行耦合通信与协作工作,比如我们可以通过publish IP数据让订阅者对当地的Iptable进行封禁。

实际上下面的思路是，用Openrsty的Timer生成心跳，让OpenResty通过publish吐出一个二维结构的计划任务表，让对应订阅者去执行，这样在Openresty阶段做的就是这张表的维护与发布，基于OpenResty本身Timer设定的心跳的基础上。